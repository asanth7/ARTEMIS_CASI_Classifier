#!/usr/bin/env python3
"""
Global vulnerability storage system for tracking found vulnerabilities across sessions.
"""

import json
import logging
import hashlib
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime, timezone
import aiofiles

class VulnerabilityStorage:
    """Session-specific storage for tracking vulnerabilities within a single supervisor run."""
    
    def __init__(self, session_dir: Path):
        """Initialize vulnerability storage for a specific session."""
        self.storage_path = session_dir / "session_vulnerabilities.jsonl"
        # Ensure the session directory exists
        self.storage_path.parent.mkdir(parents=True, exist_ok=True)
        
    def _compute_vulnerability_hash(self, vuln_data: Dict[str, Any]) -> str:
        """Compute a hash for a vulnerability to detect duplicates."""
        # Create a normalized representation for hashing
        # Focus on core vulnerability details that should be unique
        key_fields = {
            "title": vuln_data.get("title", "").strip().lower(),
            "asset": vuln_data.get("asset", "").strip().lower(),
            "vuln_type": vuln_data.get("vuln_type", "").strip().lower(),
            "description": vuln_data.get("description", "").strip().lower()[:500],  # First 500 chars
        }
        
        # Create a deterministic string from the key fields
        hash_input = json.dumps(key_fields, sort_keys=True)
        return hashlib.sha256(hash_input.encode()).hexdigest()[:16]
    
    async def log_vulnerability(self, vuln_data: Dict[str, Any], session_id: str, triager_id: str) -> str:
        """
        Log a vulnerability to the global storage.
        
        Args:
            vuln_data: Vulnerability payload (title, asset, vuln_type, severity, etc.)
            session_id: ID of the supervisor session
            triager_id: ID of the triager instance
            
        Returns:
            Vulnerability hash for tracking
        """
        vuln_hash = self._compute_vulnerability_hash(vuln_data)
        
        # Create storage entry
        storage_entry = {
            "vuln_hash": vuln_hash,
            "session_id": session_id,
            "triager_id": triager_id,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "vulnerability": vuln_data.copy()
        }
        
        # Append to JSONL file
        try:
            # Prepare the JSON line
            json_line = json.dumps(storage_entry) + "\n"
            
            # Atomic append (similar to codex history pattern)
            async with aiofiles.open(self.storage_path, 'a') as f:
                await f.write(json_line)
                
            logging.info(f"ðŸ“ Logged vulnerability {vuln_hash} to global storage: {vuln_data.get('title', 'Unknown')}")
            return vuln_hash
            
        except Exception as e:
            logging.error(f"âŒ Failed to log vulnerability to storage: {e}")
            raise
    
    async def load_all_vulnerabilities(self) -> List[Dict[str, Any]]:
        """Load all vulnerabilities from storage."""
        vulnerabilities = []
        
        if not self.storage_path.exists():
            return vulnerabilities
            
        try:
            async with aiofiles.open(self.storage_path, 'r') as f:
                async for line in f:
                    line = line.strip()
                    if line:
                        entry = json.loads(line)
                        vulnerabilities.append(entry)
                        
        except Exception as e:
            logging.error(f"âŒ Failed to load vulnerabilities from storage: {e}")
            
        return vulnerabilities
    
    async def get_vulnerability_summaries(self) -> List[Dict[str, Any]]:
        """
        Get a summary of all previously found vulnerabilities for duplicate checking.
        
        Returns:
            List of vulnerability summaries optimized for LLM context
        """
        all_vulns = await self.load_all_vulnerabilities()
        
        summaries = []
        for entry in all_vulns:
            vuln = entry["vulnerability"]
            summary = {
                "hash": entry["vuln_hash"],
                "title": vuln.get("title", "Unknown"),
                "asset": vuln.get("asset", "Unknown"),
                "type": vuln.get("vuln_type", "Unknown"),
                "severity": vuln.get("severity", "Unknown"),
                "description_preview": vuln.get("description", "")[:200] + "..." if len(vuln.get("description", "")) > 200 else vuln.get("description", ""),
                "found_in_session": entry["session_id"],
                "found_at": entry["timestamp"]
            }
            summaries.append(summary)
            
        # Sort by most recent first
        summaries.sort(key=lambda x: x["found_at"], reverse=True)
        return summaries
    
    def format_summaries_for_prompt(self, summaries: List[Dict[str, Any]]) -> str:
        """Format vulnerability summaries for inclusion in LLM prompts."""
        if not summaries:
            return "No previous vulnerabilities found in the global database."
            
        formatted = "## Previously Found Vulnerabilities (Check for Duplicates)\n\n"
        formatted += f"The following {len(summaries)} vulnerabilities have been previously identified and validated. "
        formatted += "**DO NOT report duplicates of these issues:**\n\n"
        
        for i, vuln in enumerate(summaries, 1):
            formatted += f"### {i}. {vuln['title']}\n"
            formatted += f"- **Asset:** {vuln['asset']}\n"
            formatted += f"- **Type:** {vuln['type']}\n"
            formatted += f"- **Severity:** {vuln['severity']}\n"
            formatted += f"- **Description Preview:** {vuln['description_preview']}\n"
            formatted += f"- **Found:** {vuln['found_at'][:10]} (Session: {vuln['found_in_session'][:8]}...)\n"
            formatted += f"- **Hash:** `{vuln['hash']}`\n\n"
            
        formatted += "**Before reporting any vulnerability, carefully check if it matches or is substantially similar to any of the above.**\n"
        return formatted
    
    async def check_for_duplicate(self, vuln_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Check if a vulnerability is a duplicate of an existing one.
        
        Returns:
            Existing vulnerability entry if duplicate found, None otherwise
        """
        new_hash = self._compute_vulnerability_hash(vuln_data)
        all_vulns = await self.load_all_vulnerabilities()
        
        for entry in all_vulns:
            if entry["vuln_hash"] == new_hash:
                return entry
                
        return None


# Session-specific instances
_session_vulnerability_storages = {}

def get_session_vulnerability_storage(session_dir: Path) -> VulnerabilityStorage:
    """Get the vulnerability storage instance for a specific session."""
    session_key = str(session_dir)
    if session_key not in _session_vulnerability_storages:
        _session_vulnerability_storages[session_key] = VulnerabilityStorage(session_dir)
    return _session_vulnerability_storages[session_key]
